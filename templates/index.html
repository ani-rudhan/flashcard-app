<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Flashcards</title>
    <link rel="stylesheet" href="static/style.css">
</head>
<body>
    
    <div id="controls">
        <div id="stats-panel">
            <span class="stat">Total: <strong id="stat-total">0</strong></span>
            <span class="stat stat-done">Done: <strong id="stat-done">0</strong></span>
            <span class="stat stat-redo">Redo: <strong id="stat-redo">0</strong></span>
        </div>

        <div id="filter-panel">
            <label for="view-filter">View Mode:</label>
            <select id="view-filter">
                <option value="default">Study Deck (New/Redo Cycle)</option>
                <option value="all">All Cards</option>
                <option value="done">Only Done Cards</option>
                <option value="redo">Only Redo Cards</option>
            </select>
            <input type="checkbox" id="show-hints-checkbox">
            <label for="show-hints-checkbox">Show Hints</label>

            <button id="btn-shuffle" class="btn btn-shuffle">Shuffle Cards</button>

            <button id="btn-reset" class="btn btn-reset">Reset Stats</button>
        </div>
        
        <div id="search-panel">
            <input type="text" id="search-input" placeholder="Search by Meaning...">
            <button id="btn-search" class="btn btn-search">Search</button>
        </div>
    </div>

    <div class="container">
        {% for card in cards %}
        <div class="flashcard" data-meaning="{{ card['Meaning'] | lower }}">
            <div class="front">
                <div class="topic">
                    <p><strong>{{ card['Topic'] }}</strong></p>
                </div>
                <div class="audio">
                    <p><strong>{{ card['Audio'] }}</strong></p>
                </div>
                <div class="word">
                    <p><strong>{{ card['Word'] }}</strong></p>
                </div>
            </div>
            <div class="back">
                <div class="back-content-area">
                    <div class="kanji">
                        <p>{{ card['Kanji'] }}</p>
                    </div>
                    <div class="meaning">
                        <p>{{ card['Meaning'] }}</p>
                    </div>
                </div>
                
                <div class="notes">
                    <p><strong>Notes:</strong> {{ card['Notes'] }}</p>
                </div>                
                
                <div class="feedback-buttons">
                    <button class="btn btn-done">Done</button>
                    <button class="btn btn-redo">Redo</button>
                </div>
            </div>
        </div>
        {% endfor %}
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const CARD_LIMIT = 6;
        let flashcards = Array.from(document.querySelectorAll('.flashcard')); // Use 'let' for reordering
        const totalCards = flashcards.length;
        const viewFilter = document.getElementById('view-filter');
        const btnReset = document.getElementById('btn-reset'); 
        const showHintsCheckbox = document.getElementById('show-hints-checkbox'); 
        
        // Search elements
        const searchInput = document.getElementById('search-input');
        const btnSearch = document.getElementById('btn-search');
        
        // NEW Shuffle element
        const btnShuffle = document.getElementById('btn-shuffle');
        
        // Stat elements
        const statTotal = document.getElementById('stat-total');
        const statDone = document.getElementById('stat-done');
        const statRedo = document.getElementById('stat-redo');

        const getFlashcard = (element) => element.closest('.flashcard');

        // Fisher-Yates (Knuth) Shuffle Algorithm
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function updateCardDOMOrder() {
            const container = document.querySelector('.container');
            // Re-append the cards to the DOM in their new order
            flashcards.forEach(card => container.appendChild(card));
        }

        function updateStats() {
            const doneCount = flashcards.filter(card => card.classList.contains('done-mark')).length;
            const redoCount = flashcards.filter(card => card.classList.contains('redo-mark')).length;
            
            statTotal.textContent = totalCards;
            statDone.textContent = doneCount;
            statRedo.textContent = redoCount;
        }

        // --- CORE DECK MANAGEMENT FUNCTION ---
        function updateDeckView(filterMode = viewFilter.value, searchQuery = '') {
            
            // 1. Reset visibility for all cards
            flashcards.forEach(card => {
                card.classList.add('hidden');
            });
            
            const normalizedQuery = searchQuery.trim().toLowerCase();
            let cardsToProcess = flashcards;
            
            // 2. Apply Search Filter (Highest Priority)
            if (normalizedQuery) {
                // If searching, ignore standard view mode and show matching cards
                cardsToProcess = flashcards.filter(card => {
                    const meaning = card.getAttribute('data-meaning') || '';
                    return meaning.includes(normalizedQuery);
                });
                
                // Show all found cards in the search view
                cardsToProcess.forEach(card => card.classList.remove('hidden'));
                return; // Stop processing to keep all search results visible
            }


            // 3. Apply Standard View Filter (Only if not searching)
            let cardsToDisplay = [];

            if (filterMode === 'default') {
                // IMPORTANT: Filter by status, then take the first 6
                let redoCards = cardsToProcess.filter(card => card.classList.contains('redo-mark'));
                let newCards = cardsToProcess.filter(card => 
                    !card.classList.contains('redo-mark') && !card.classList.contains('done-mark')
                );

                // Prioritize New cards, then Redo cards
                let studyDeck = newCards.concat(redoCards);
                
                // Take only the limit for display
                cardsToDisplay = studyDeck.slice(0, CARD_LIMIT);
                
                // Reset 'done' status on any 'redo' cards shown, so they cycle again
                cardsToDisplay.forEach(card => card.classList.remove('done-mark'));

            } else if (filterMode === 'all') {
                cardsToDisplay = cardsToProcess;
            } else if (filterMode === 'done') {
                cardsToDisplay = cardsToProcess.filter(card => card.classList.contains('done-mark'));
            } else if (filterMode === 'redo') {
                cardsToDisplay = cardsToProcess.filter(card => card.classList.contains('redo-mark'));
            }

            // 4. Show the final set of cards
            cardsToDisplay.forEach(card => card.classList.remove('hidden'));
        }
        
        function resetDeck() {
            flashcards.forEach(card => {
                card.classList.remove('done-mark', 'redo-mark', 'flipped');
            });
            viewFilter.value = 'default';
            searchInput.value = ''; // Clear search on reset
            updateStats();
            // Do not shuffle on reset, just update the view
            updateDeckView('default');
        }


        // --- EVENT HANDLERS ---

        // Card Flip 
        document.querySelectorAll('.flashcard').forEach(card => {
            card.addEventListener('click', (e) => {
                if (!e.target.closest('.btn')) {
                    card.classList.toggle('flipped');
                }
            });
        });

        // Done/Redo Button Logic
        document.querySelectorAll('.btn-redo').forEach(button => {
            button.addEventListener('click', (e) => {
                const flashcard = getFlashcard(e.target);
                flashcard.classList.add('redo-mark');
                flashcard.classList.remove('done-mark'); 
                flashcard.classList.remove('flipped'); 
                updateStats();
                updateDeckView(viewFilter.value, searchInput.value); 
            });
        });

        document.querySelectorAll('.btn-done').forEach(button => {
            button.addEventListener('click', (e) => {
                const flashcard = getFlashcard(e.target);
                flashcard.classList.add('done-mark');
                flashcard.classList.remove('redo-mark'); 
                flashcard.classList.remove('flipped');
                updateStats();
                updateDeckView(viewFilter.value, searchInput.value); 
            });
        });

        // Filter Dropdown Change
        viewFilter.addEventListener('change', (e) => {
            updateDeckView(e.target.value, searchInput.value);
        });

        // Reset Button Handler
        btnReset.addEventListener('click', resetDeck);
        
        // Show Hints Toggle Handler
        showHintsCheckbox.addEventListener('change', (e) => {
            if (e.target.checked) {
                document.body.classList.add('show-hints');
            } else {
                document.body.classList.remove('show-hints');
            }
        });
        
        // Search Button/Input Handlers
        const handleSearch = () => {
             // Change view to 'all' to show all matches
            viewFilter.value = 'all'; 
            updateDeckView(viewFilter.value, searchInput.value);
        };
        btnSearch.addEventListener('click', handleSearch);
        searchInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                handleSearch();
            }
        });

        // NEW: Shuffle Button Handler
        btnShuffle.addEventListener('click', () => {
            shuffleArray(flashcards);
            updateCardDOMOrder(); // Update the HTML order
            // Keep the current view mode, but apply it to the newly shuffled deck
            updateDeckView(viewFilter.value, searchInput.value);
            console.log("Cards shuffled.");
        });

        // --- INITIALIZATION ---
        statTotal.textContent = totalCards;
        updateStats();
        // Initial shuffle for the first view
        shuffleArray(flashcards); 
        updateCardDOMOrder();
        updateDeckView();
    });
</script>
</body>
</html>